{"version":3,"sources":["types/ciphers.ts","types/state.ts","crypto/common.ts","crypto/keyword.ts","store/reducers/keywordReducer.ts","crypto/masc.ts","store/reducers/mascReducer.ts","crypto/caesar.ts","store/reducers/caesarReducer.ts","store/reducers/formattingReducer.ts","store/reducers/cryptoReducer.ts","store/reducers/mainReducer.ts","types/actions.ts","store/configureStore.ts","store/actionGenerators.ts","components/InputBox/InputBox.tsx","components/OutputBox/OutputBox.tsx","components/KeywordSection/KeyInput/KeyInput.tsx","components/AlphabetDisplay/AlphabetDisplay.tsx","components/KeywordSection/KeywordSection.tsx","components/CipherSelector/CipherSelector.tsx","components/MascSection/KeyLetter/KeyLetter.tsx","components/MascSection/MascSection.tsx","components/CaesarSection/CaesarSection.tsx","components/CiphersSection/CiphersSection.tsx","components/Credits/Credits.tsx","components/App/App.tsx","index.tsx"],"names":["Ciphers","defaultState","input","output","cipher","CAESAR","decrypt","preserveFormatting","keywordSection","keyword","keyletter","validKeyword","validKeyletter","mascSection","letters","Array","fill","caesarSection","shift","alphabet","encryptTextFromCtAlphabet","plaintext","ctAlphabet","ptAlphabet","ciphertext","i","length","indexOf","toLowerCase","generateCiphertextAlphabet","unshiftedCtAlphabet","stripDuplicateLetters","toUpperCase","startIndex","charCodeAt","keywordSectionReducer","ks","action","isValidKeyword","isValidKeyletter","keyLetter","keywordEncrypt","keySectionValid","keywordDecrypt","inputCiphertext","decryptText","num","alphabetUppercaseArray","from","convertAlphabets","srcAlphabet","destAlphabet","out","charIndex","mascSectionReducer","ms","newLetter","newValue","includes","changedIndex","mascEncrypt","ctLetters","mascDecrypt","map","currVal","index","join","caesarSectionReducer","cs","caesarEncrypt","caesarDecrypt","formattingReducer","str","newOutput","ch","test","stripNonAlpha","blockLength","splitIntoBlocks","generateOutput","state","formattedInput","KEYWORD","MASC","mainReducer","type","inputText","store","createStore","composeWithDevTools","updateKeywordSection","updateCipherSelector","myDispatcher","dispatch","InputBox","props","className","onChange","evt","updateInputValue","value","this","newInput","target","setState","React","Component","connect","OutputBox","readOnly","KeyInput","updateKeywordValue","updateKeyLetterValue","newKeyword","newKeyletter","AlphabetDisplay","generateAlphabets","push","key","KeywordSection","getCtAlphabet","cipherList","Map","CipherSelector","options","forEach","enumValue","displayName","selected","handleCipherChange","name","checked","handleDirectionChange","handlePreserveFormattingChange","get","undefined","KeyLetter","handleChange","updateMascLetter","MascSection","keyLetters","letterValues","CaesarSection","handleKeyLetterChange","parseInt","CiphersSection","Credits","href","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6d405fc7.chunk.js","sourcesContent":["\nexport enum Ciphers {\n    KEYWORD = \"Keyword\",\n    MASC = \"MASC\",\n    CAESAR = \"CAESAR\"\n}\n","import { Ciphers } from \"./ciphers\";\n\nexport interface IAppState {\n    input: string;\n    output: string;\n    cipher: Ciphers;\n    decrypt: boolean;\n    preserveFormatting: boolean;\n    keywordSection: IKeywordSection;\n    mascSection: IMascSection;\n    caesarSection: ICaesarSection;\n}\n\nexport interface IKeywordSection {\n    keyword: string;\n    validKeyword: boolean;\n    keyletter: string;\n    validKeyletter: boolean;\n}\n\nexport interface ICaesarSection {\n    shift: number;\n}\n\nexport interface IMascSection {\n    letters: string[]; // exactly 26 elements, the CT letters in order as they correlate to the standard alphabet\n}\n\nexport const defaultState: IAppState = {\n    input: \"Enter your text here...\",\n    output: \"\",\n    \n    cipher: Ciphers.CAESAR,\n    decrypt: false,\n    preserveFormatting: true,\n\n    keywordSection: {\n        keyword: \"\",\n        keyletter: \"\",\n        validKeyword: false,\n        validKeyletter: false\n    },\n\n    mascSection: {\n        // Bad things happen if the array isn't already populated with empty strings\n        // If you set value={undefined} on an input element, it's not considered controlled.\n        // I want my KeyLetter <input>s to be controlled, so the array needs to be filled with\n        // something other than `undefined`.  An empty string works beautifully.\n        // https://reactjs.org/docs/forms.html#controlled-input-null-value\n        letters: Array<string>(26).fill(\"\")\n    },\n\n    caesarSection: {\n        shift: 0\n    }\n};\n","export const alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n// This function assumes that {ctAlphabet} is UPPERCASE, and {alphabet} is lowercase\n// You can use this function to decrypt by putting the plaintext alphabet in {ctAlphabet} and vice versa\n// (just make sure you convert them to the proper case first!)\nexport function encryptTextFromCtAlphabet(plaintext: string, ctAlphabet: string, ptAlphabet: string) {\n    // Remember: {ctAlphabet} is UPPERCASE, {alphabet} is lowercase\n    let ciphertext = \"\";\n    \n    for (let i=0; i < plaintext.length; i++) {\n        // If the plaintext is lowercase\n        if ( ptAlphabet.indexOf(plaintext[i]) !== -1 ) {\n            // console.log('lowercase')\n            let charIndex = ptAlphabet.indexOf(plaintext[i]); // grab the index in the alphabet\n            let newChar = ctAlphabet[charIndex]; // grab the corresponding ciphertext letter\n            ciphertext += newChar.toLowerCase(); // Append lowercase letter to ciphertext\n        }\n        // If the plaintext is uppercase\n        else if ( ptAlphabet.indexOf(plaintext[i].toLowerCase()) !== -1 ) {\n            // Same steps as above, but swapping the case\n            let charIndex = ptAlphabet.indexOf(plaintext[i].toLowerCase());\n            let newChar = ctAlphabet[charIndex];\n            ciphertext += newChar;\n        }\n        // If it's not a letter, then just copy it to the ciphertext\n        else {\n            ciphertext += plaintext[i];\n        }\n    }\n\n    return ciphertext;\n}\n","/*****************************************\n *** NOTE ***\n * All functions in this file assume that the keyword and keyletter has been properly sanitized.\n * \"Properly sanitized\" means that the keyword contains only letters, and that the keyletter is\n * exactly one character long.\n * \n * Also, all plaintext alphabets will be returned lowercase, and ciphertext alphabets will be uppercase.\n *****************************************/\nimport { alphabet, encryptTextFromCtAlphabet } from './common';\n\nexport function encryptText(plaintext: string, keyword: string, keyletter: string) {\n    return encryptTextFromCtAlphabet(plaintext, generateCiphertextAlphabet(keyword, keyletter), alphabet);\n}\n\nexport function decryptText(inputCiphertext: string, keyword: string, keyletter: string) {\n    let ctAlphabet = generateCiphertextAlphabet(keyword, keyletter);\n    return encryptTextFromCtAlphabet(inputCiphertext, alphabet.toUpperCase(), ctAlphabet.toLowerCase());\n}\n\nfunction stripDuplicateLetters(input: string) {\n    let output: string = \"\";\n    for (let i=0; i<input.length; i++) {\n        if (output.indexOf(input[i].toLowerCase()) === -1) {\n            output += input[i].toLowerCase();\n        }\n    }\n    return output;\n}\n\nexport function generateCiphertextAlphabet(keyword: string, keyletter: string) {\n    let unshiftedCtAlphabet = stripDuplicateLetters(keyword + alphabet).toUpperCase();\n    let ctAlphabet = \"\";\n    let startIndex = keyletter.toLowerCase().charCodeAt(0) - 97;\n\n    for (let i=0; i<26; i++) {\n        let nextLetterIndex = (i + (26 - startIndex)) % 26\n        ctAlphabet += unshiftedCtAlphabet[nextLetterIndex];\n    }\n\n    return ctAlphabet;\n}\n","import { IKeywordSection } from \"../../types/state\";\nimport { UpdateKeywordSectionAction } from \"../../types/actions\";\nimport { encryptText, decryptText } from \"../../crypto/keyword\";\n\nexport function keywordSectionReducer(ks: IKeywordSection, action: UpdateKeywordSectionAction): IKeywordSection {\n    // If they are valid OR empty, allow them into the state\n    if (isValidKeyword(action.keyword) || action.keyword.length === 0) {\n        ks = { ...ks,\n            keyword: action.keyword\n        };\n    }\n    if (isValidKeyletter(action.keyLetter) || action.keyLetter.length === 0) {\n        ks = { ...ks,\n            keyletter: action.keyLetter\n        };\n    }\n    \n    // Validate!\n    ks = { ...ks,\n        validKeyword: isValidKeyword(ks.keyword),\n        validKeyletter: isValidKeyletter(ks.keyletter)\n    }\n    \n    return ks;\n}\n\nexport function keywordEncrypt(ks: IKeywordSection, input: string): string {\n    return keySectionValid(ks) ? encryptText(input, ks.keyword, ks.keyletter) : \"\";\n}\n\nexport function keywordDecrypt(ks: IKeywordSection, input: string): string {\n    return keySectionValid(ks) ? decryptText(input, ks.keyword, ks.keyletter) : \"\";\n}\n\nfunction keySectionValid(ks: IKeywordSection): boolean {\n    return isValidKeyword(ks.keyword) && isValidKeyletter(ks.keyletter);\n}\n\nfunction isValidKeyword(input: string) {\n    if (input.length === 0) {\n        return false;\n    }\n    for (var i = 0; i < input.length; i++) {\n        let num = input.toLowerCase().charCodeAt(i) - 97;\n        if (num < 0 || num > 25) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isValidKeyletter(input: string) {\n    return (input.length === 1) && isValidKeyword(input);\n}\n","import { alphabet } from \"./common\";\n\nconst PAD_CHARACTER = \"*\"; // for when a letter hasn't been typed yet\n\nexport function encryptText(plaintext: string, ctLetters: string[]): string {\n    return convertAlphabets(alphabetUppercaseArray(), ctLetters, plaintext);\n}\n\nexport function decryptText(ciphertext: string, ctLetters: string[]): string {\n    return convertAlphabets(ctLetters, alphabetUppercaseArray(), ciphertext);\n}\n\nfunction alphabetUppercaseArray(): string[] {\n    return Array.from(alphabet.toUpperCase());\n}\n\n// This function assumes that both alphabets are given as UPPERCASE\n// Either srcAlphabet or destAlphabet could have missing elements, depending on if we're encrypting or decrypting\n// So we need to account for empty slots in either!\nfunction convertAlphabets(srcAlphabet: string[], destAlphabet: string[], input: string): string {\n    let out = \"\";\n    \n    for (let i = 0; i < input.length; i++) {\n        // if the input is uppercase\n        if (srcAlphabet.indexOf(input[i]) !== -1) {\n            let charIndex = srcAlphabet.indexOf(input[i]);\n            // Check that the destination char exists, otherwise pad\n            if (destAlphabet[charIndex] === \"\") {\n                out += PAD_CHARACTER;\n            } else {\n                out += destAlphabet[charIndex];\n            }\n        }\n        // if the input is lowercase\n        else if (srcAlphabet.indexOf(input[i].toUpperCase()) !== -1) {\n            // Same as above, but lowercase\n            let charIndex = srcAlphabet.indexOf(input[i].toUpperCase());\n            if (destAlphabet[charIndex] === \"\") {\n                out += PAD_CHARACTER;\n            } else {\n                out += destAlphabet[charIndex].toLowerCase();\n            }\n        }\n        // if the character is alpha but not in srcAlphabet (upper or lower case)\n        else if (alphabet.indexOf(input[i]) !== -1 || alphabet.toUpperCase().indexOf(input[i]) !== -1 ) {\n            out += PAD_CHARACTER;\n        }\n        // if it's not a letter at all, then just copy from the input\n        else {\n            out += input[i];\n        }\n    }\n\n    return out;\n}\n","import { IMascSection } from \"../../types/state\";\nimport { UpdateMascLetterAction } from \"../../types/actions\";\nimport { encryptText, decryptText } from \"../../crypto/masc\";\n\nexport function mascSectionReducer(ms: IMascSection, action: UpdateMascLetterAction): IMascSection {\n    let newLetter = action.newValue.toUpperCase();\n    \n    // The new letter must be 0 or 1 characters long.\n    // It also must either be empty or not already exist in the array.\n    if (newLetter.length < 2 && ( newLetter === \"\" || !ms.letters.includes(newLetter) )) {\n        ms.letters[action.changedIndex] = newLetter;\n    }\n    \n    // The array object itself needs to change, otherwise React doesn't react to the change.\n    ms.letters = Array.from(ms.letters);\n\n    return ms;\n}\n\nexport function mascEncrypt(ms: IMascSection, input: string): string {\n    return encryptText(input, ms.letters);\n}\n\nexport function mascDecrypt(ms: IMascSection, input: string): string {\n    return decryptText(input, ms.letters);\n}\n","/*\nNOTE: All exported functions expect the input to be sanitized.\n(meaning, 'keyletter' is a single UPPERCASE letter)\n*/\n\nimport { alphabet, encryptTextFromCtAlphabet } from './common';\n\nexport function encryptText(plaintext: string, shift: number) {\n    return encryptTextFromCtAlphabet(plaintext, generateCiphertextAlphabet(shift), alphabet);\n}\n\nexport function decryptText(inputCiphertext: string, shift: number) {\n    let ctAlphabet = generateCiphertextAlphabet(shift);\n    return encryptTextFromCtAlphabet(inputCiphertext, alphabet.toUpperCase(), ctAlphabet.toLowerCase());\n}\n\nexport function generateCiphertextAlphabet(shift: number): string {\n    let ctAlphabetArray = Array.from(alphabet).map(\n        (currVal: string, index: number) => { return alphabet[(index + shift) % 26]; }\n    );\n    return ctAlphabetArray.join('').toUpperCase();\n}\n","import { ICaesarSection } from \"../../types/state\";\nimport { UpdateCaesarAction } from \"../../types/actions\";\nimport { encryptText, decryptText } from \"../../crypto/caesar\";\n\nexport function caesarSectionReducer(cs: ICaesarSection, action: UpdateCaesarAction): ICaesarSection {\n    cs.shift = (action.shift + 26) % 26; // Don't allow negative numbers\n    return cs;\n}\n\nexport function caesarEncrypt(cs: ICaesarSection, input: string): string {\n    return encryptText(input, cs.shift);\n}\n\nexport function caesarDecrypt(cs: ICaesarSection, input: string): string {\n    return decryptText(input, cs.shift);\n}\n","const BLOCK_LENGTH = 5;\n\nexport function formattingReducer(str: string, preserveFormatting: boolean): string {\n    if (! preserveFormatting) {\n        let newOutput = stripNonAlpha(str);\n        newOutput = newOutput.toUpperCase();\n        newOutput = splitIntoBlocks(newOutput, BLOCK_LENGTH);\n        return newOutput;\n    } else {\n        return str;\n    }\n}\n\nfunction stripNonAlpha(str: string): string {\n    let out = \"\";\n\n    for(let i=0; i<str.length; i++) {\n        if (isAlpha(str[i])) {\n            out += str[i];\n        }\n    }\n\n    return out;\n}\n\nfunction splitIntoBlocks(str: string, blockLength: number): string {\n    let out = \"\";\n    for (let i=0; i<str.length; i++) {\n        out += str[i];\n\n        if (i>0 && (i+1) % blockLength === 0) {\n            out += \" \";\n        }\n    }\n    return out;\n}\n\n// Thanks StackOverflow\n// https://stackoverflow.com/questions/40120915/javascript-function-that-returns-true-if-a-letter\nfunction isAlpha(ch: string): boolean {\n    return /^[A-Z]$/i.test(ch);\n}\n","import { IAppState } from \"../../types/state\";\nimport { Ciphers } from \"../../types/ciphers\";\nimport { keywordDecrypt, keywordEncrypt } from \"./keywordReducer\";\nimport { mascDecrypt, mascEncrypt } from \"./mascReducer\";\nimport { caesarDecrypt, caesarEncrypt } from \"./caesarReducer\";\nimport { formattingReducer } from \"./formattingReducer\";\n\nexport function generateOutput(state: IAppState): string {\n\n    let formattedInput = formattingReducer(state.input, state.preserveFormatting);\n\n    switch (state.cipher) {\n        case Ciphers.KEYWORD:\n            return state.decrypt ? keywordDecrypt(state.keywordSection, formattedInput) : keywordEncrypt(state.keywordSection, formattedInput);\n        \n        case Ciphers.MASC:\n            return state.decrypt ? mascDecrypt(state.mascSection, formattedInput) : mascEncrypt(state.mascSection, formattedInput);\n\n        case Ciphers.CAESAR:\n            return state.decrypt ? caesarDecrypt(state.caesarSection, formattedInput) : caesarEncrypt(state.caesarSection, formattedInput);\n    }\n}\n","import { AppActions, UPDATE_KEYWORDSECTION, UPDATE_INPUT, UPDATE_CIPHERSECTION, UPDATE_MASCLETTER, UPDATE_CAESARSECTION } from \"../../types/actions\";\nimport { IAppState, defaultState } from \"../../types/state\";\nimport { keywordSectionReducer} from \"./keywordReducer\";\nimport { mascSectionReducer } from \"./mascReducer\";\nimport { generateOutput } from \"./cryptoReducer\";\nimport { caesarSectionReducer } from \"./caesarReducer\";\n\nfunction mainReducer (state: IAppState = defaultState, action: AppActions): IAppState {\n\n    switch (action.type) {\n        case UPDATE_CIPHERSECTION:\n            state = { ...state,\n                cipher: action.cipher,\n                decrypt: action.decrypt,\n                preserveFormatting: action.preserveFormatting,\n                output: \"\",\n            }\n            break;\n\n        case UPDATE_KEYWORDSECTION:\n            state = { ...state,\n                keywordSection: keywordSectionReducer(state.keywordSection, action)\n            }\n            break;\n\n        case UPDATE_MASCLETTER:\n            state = { ...state,\n                mascSection: mascSectionReducer(state.mascSection, action)\n            }\n            break;\n\n        case UPDATE_CAESARSECTION:\n            state = { ...state,\n                caesarSection: caesarSectionReducer(state.caesarSection, action)\n            }\n            break;\n        \n        case UPDATE_INPUT:\n            state = { ...state, input: action.inputText }\n    }\n\n    \n    // At the end of every update, recalculate the output based on the cipher and en/de-crypt selections\n    state = { ...state,\n        output: generateOutput(state)\n    }\n\n    return state;\n}\n\nexport default mainReducer;\n","import { Ciphers } from \"./ciphers\";\n\nexport const UPDATE_INPUT = \"UPDATE_INPUT\";\nexport const UPDATE_CIPHERSECTION = \"UPDATE_CIPHERSECTION\";\nexport const UPDATE_KEYWORDSECTION = \"UPDATE_KEYWORDSECTION\";\nexport const UPDATE_MASCLETTER = \"UPDATE_MASCLETTER\";\nexport const UPDATE_CAESARSECTION = \"UPDATE_CAESARSECTION\";\n\nexport interface UpdateKeywordSectionAction {\n    type: typeof UPDATE_KEYWORDSECTION;\n    keyword: string;\n    keyLetter: string;\n}\n\nexport interface UpdateInputAction {\n    type: typeof UPDATE_INPUT;\n    inputText: string;\n}\n\nexport interface UpdateCipherSectionAction {\n    type: typeof UPDATE_CIPHERSECTION;\n    cipher: Ciphers;\n    decrypt: boolean;\n    preserveFormatting: boolean;\n}\n\nexport interface UpdateMascLetterAction {\n    type: typeof UPDATE_MASCLETTER;\n    changedIndex: number;\n    newValue: string;\n}\n\nexport interface UpdateCaesarAction {\n    type: typeof UPDATE_CAESARSECTION;\n    shift: number;\n}\n\n// Aggregate type for all actions\nexport type AppActions = UpdateKeywordSectionAction | UpdateInputAction | UpdateCipherSectionAction | UpdateMascLetterAction | UpdateCaesarAction;\n","import { createStore } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport mainReducer from './reducers/mainReducer';\n\nexport const store = createStore(mainReducer, composeWithDevTools());\n","import { AppActions, UPDATE_KEYWORDSECTION, UPDATE_INPUT, UPDATE_CIPHERSECTION, UPDATE_MASCLETTER, UpdateMascLetterAction, UpdateCipherSectionAction, UpdateInputAction, UpdateKeywordSectionAction, UpdateCaesarAction, UPDATE_CAESARSECTION } from \"../types/actions\";\nimport { store } from \"./configureStore\";\nimport { Ciphers } from \"../types/ciphers\";\n\nexport function updateKeywordSection(keyword: string, keyLetter: string): UpdateKeywordSectionAction {\n    return {\n        type: UPDATE_KEYWORDSECTION,\n        keyword: keyword,\n        keyLetter: keyLetter\n    };\n}\n\nexport function updateInput(input: string): UpdateInputAction {\n    return {\n        type: UPDATE_INPUT,\n        inputText: input\n    };\n}\n\nexport function updateCipherSelector(cipher: Ciphers, decrypt: boolean, preserveFormatting: boolean): UpdateCipherSectionAction {\n    return {\n        type: UPDATE_CIPHERSECTION,\n        cipher,\n        decrypt,\n        preserveFormatting\n    };\n}\n\nexport function updateMascLetter(changedIndex: number, newValue: string): UpdateMascLetterAction {\n    return {\n        type: UPDATE_MASCLETTER,\n        changedIndex,\n        newValue\n    };\n}\n\nexport function updateCaesarLetter(newShift: number): UpdateCaesarAction {\n    return {\n        type: UPDATE_CAESARSECTION,\n        shift: newShift\n    }\n}\n\n// Is this hacky?  It seems so simple, but nothing online even came close to suggesting it...\nexport function myDispatcher(action: AppActions) {\n    store.dispatch(action);\n}\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { IAppState } from \"../../types/state\";\nimport { myDispatcher, updateInput } from \"../../store/actionGenerators\";\n\ninterface InputBoxProps {\n    input: string\n}\n\ninterface InputBoxState {\n    input: string\n}\n\nclass InputBox extends React.Component<InputBoxProps, InputBoxState> {\n    constructor(props: InputBoxProps) {\n        super(props);\n        this.state = { input: this.props.input };\n    }\n\n    render() {\n        return <div className='InputBox'>\n            <textarea onChange={evt => this.updateInputValue(evt)} value={this.state.input}></textarea>\n        </div>;\n    }\n\n    updateInputValue(evt: React.ChangeEvent<HTMLTextAreaElement>) {\n        let newInput = evt.target.value;\n        this.setState({ input: newInput });\n        myDispatcher(updateInput(newInput));\n    }\n}\n\nfunction mapStateToProps(state: IAppState): InputBoxProps {\n    return { input: state.input };\n}\n\nexport default connect(mapStateToProps)(InputBox);\n","import React from 'react'\nimport { IAppState } from '../../types/state';\nimport { connect } from 'react-redux';\n\ninterface OutputBoxProps {\n    output: string;\n}\n\ninterface OutputBoxState {\n}\n\nclass OutputBox extends React.Component<OutputBoxProps, OutputBoxState> {\n    render() {\n        return <div className='OutputBox'>\n            <textarea value={this.props.output} readOnly></textarea>\n        </div>;\n    }\n}\n\nfunction mapStateToProps(state: IAppState): OutputBoxProps {\n    return { output: state.output };\n}\n\nexport default connect(mapStateToProps)(OutputBox);\n","import React from \"react\";\nimport { myDispatcher, updateKeywordSection } from \"../../../store/actionGenerators\";\nimport './KeyInput.scss';\n\ninterface KeyInputProps {\n        keyword: string;\n        keyletter: string;\n}\n\nclass KeyInput extends React.Component<KeyInputProps> {\n    constructor(props: KeyInputProps) {\n        super(props);\n        this.state = { keyword: \"\", keyletter: \"\" };\n    }\n\n    render() {\n        return <div className=\"KeyInput\">\n            <div className=\"gridLayout\">\n                <label>Keyword</label>\n                <input type=\"text\" value={this.props.keyword} onChange={evt => this.updateKeywordValue(evt)} />\n\n                <label>Key letter</label>\n                <input type=\"text\" value={this.props.keyletter} onChange={evt => this.updateKeyLetterValue(evt)} />\n            </div>\n        </div>;\n    }\n\n    updateKeywordValue(evt: React.ChangeEvent<HTMLInputElement>) {\n        var newKeyword = evt.target.value;\n        this.setState({ keyword: newKeyword });\n        myDispatcher(updateKeywordSection(newKeyword, this.props.keyletter));\n    }\n\n    updateKeyLetterValue(evt: React.ChangeEvent<HTMLInputElement>) {\n        var newKeyletter = evt.target.value;\n        this.setState({ keyletter: newKeyletter });\n        myDispatcher(updateKeywordSection(this.props.keyword, newKeyletter));\n    }\n}\n\nexport default KeyInput;\n","import React from \"react\";\nimport { alphabet } from \"../../crypto/common\";\nimport './AlphabetDisplay.scss';\n\n// ctAlphabet is expected to be exactly 26 characters long and uppercase\ninterface AlphabetDisplayProps {\n    ctAlphabet: string;\n}\n\nclass AlphabetDisplay extends React.Component<AlphabetDisplayProps> {\n    render() {\n        return <div className=\"AlphabetDisplay\">\n            <div className=\"AlphabetDisplayHeader\">\n                <p>Plaintext</p>\n                <p>Ciphertext</p>\n            </div>\n            {this.generateAlphabets()}\n        </div>;\n    }\n\n    generateAlphabets() : JSX.Element[] {\n        let letters: JSX.Element[] = [];\n\n        for (let i=0; i<alphabet.length; i++) {\n            letters.push(\n                <div className=\"AlphabetDisplayLetter\" key={i}>\n                    <p>{alphabet[i]}</p>\n                    <p>{this.props.ctAlphabet[i]}</p>\n                </div>\n            );\n        }\n\n        return letters;\n    }\n}\n\nexport default AlphabetDisplay;\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport KeyInput from './KeyInput/KeyInput';\nimport { IKeywordSection, IAppState } from '../../types/state';\nimport { generateCiphertextAlphabet } from '../../crypto/keyword';\nimport AlphabetDisplay from '../AlphabetDisplay/AlphabetDisplay';\n\ntype KeySectionProps = IKeywordSection;\n\nclass KeywordSection extends React.Component<KeySectionProps> {\n    render() {\n        return <div>\n            <KeyInput keyword={this.props.keyword} keyletter={this.props.keyletter} />\n            {   // Shortcut syntax to render alphabetSection only if the below 2 booleans are true\n                this.props.validKeyword && this.props.validKeyletter && <AlphabetDisplay ctAlphabet={this.getCtAlphabet()} />\n            }\n        </div>;\n    }\n\n    getCtAlphabet(): string {\n        return generateCiphertextAlphabet(this.props.keyword, this.props.keyletter);\n    }\n}\n\nfunction mapStateToProps (state: IAppState): KeySectionProps {\n    return state.keywordSection;\n}\n\nexport default connect(mapStateToProps)(KeywordSection);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { Ciphers } from \"../../types/ciphers\";\nimport { IAppState } from \"../../types/state\";\nimport { myDispatcher, updateCipherSelector } from \"../../store/actionGenerators\";\nimport './CipherSelector.scss'\n\ninterface CipherSelectorProps {\n    cipher: Ciphers,\n    preserveFormatting: boolean,\n    decrypt: boolean\n}\n\nconst cipherList = new Map<string, Ciphers>([\n    [\"Caesar\", Ciphers.CAESAR],\n    [\"MASC\", Ciphers.MASC],\n    [\"Keyword\", Ciphers.KEYWORD],\n]);\n\nclass CipherSelector extends React.Component<CipherSelectorProps> {\n    render() {\n        let options: JSX.Element[] = [];\n        cipherList.forEach(\n            (enumValue: Ciphers, displayName: string) => {\n                options.push(<option key={enumValue} value={displayName} selected={enumValue === this.props.cipher} >{displayName}</option>);\n            }\n        );\n\n        return <div className=\"CipherSelector\">\n            <div className=\"Cipher\">\n                <select onChange={evt => this.handleCipherChange(evt)}>\n                    { options }\n                </select>\n            </div>\n            <div className=\"Direction\">\n                <label><input type=\"radio\" name=\"direction\" value=\"encrypt\" checked={this.props.decrypt === false} onChange={() => this.handleDirectionChange(false)} />Encrypt</label><br />\n                <label><input type=\"radio\" name=\"direction\" value=\"decrypt\" checked={this.props.decrypt === true}  onChange={() => this.handleDirectionChange(true)}  />Decrypt</label>\n            </div>\n            <div className=\"PreserveFormatting\">\n                <label><input type=\"checkbox\" name=\"preserveFormatting\" checked={this.props.preserveFormatting} onChange={() => this.handlePreserveFormattingChange()} />Preserve Formatting</label>\n            </div>\n        </div>;\n    }\n\n    handleCipherChange(evt: React.ChangeEvent<HTMLSelectElement>) {\n        let cipher = cipherList.get(evt.target.value);\n        if (cipher !== undefined) {\n            myDispatcher(updateCipherSelector(cipher, this.props.decrypt, this.props.preserveFormatting));\n        }\n    }\n    \n    handleDirectionChange(decrypt: boolean) {\n        myDispatcher(updateCipherSelector(this.props.cipher, decrypt, this.props.preserveFormatting));\n    }\n    \n    handlePreserveFormattingChange() {\n        // This one is just a simple toggle\n        myDispatcher(updateCipherSelector(this.props.cipher, this.props.decrypt, ! this.props.preserveFormatting));\n    }\n}\n\nfunction mapStateToProps(state: IAppState): CipherSelectorProps {\n    return {\n        cipher: state.cipher,\n        preserveFormatting: state.preserveFormatting,\n        decrypt: state.decrypt\n    }\n}\n\nexport default connect(mapStateToProps)(CipherSelector);\n","import React from \"react\";\nimport { myDispatcher, updateMascLetter } from \"../../../store/actionGenerators\";\nimport { alphabet } from \"../../../crypto/common\";\n\ninterface KeyLetterProps {\n    index: number;\n    value: string;\n};\n\nclass KeyLetter extends React.Component<KeyLetterProps> {\n    constructor(props: KeyLetterProps) {\n        super(props);\n        this.state = { value: this.props.value };\n    }\n\n    render() {\n        return <div className=\"KeyLetter\">\n            <label>{alphabet[this.props.index]}</label>\n            <input type=\"text\" value={this.props.value} onChange={evt => this.handleChange(evt)} />\n        </div>;\n    }\n\n    handleChange(evt: React.ChangeEvent<HTMLInputElement>) {\n        let newValue = evt.target.value.toUpperCase();\n        myDispatcher(updateMascLetter(this.props.index, newValue));\n    }\n}\n\nexport default KeyLetter;\n","import React from \"react\";\nimport { alphabet } from \"../../crypto/common\";\nimport KeyLetter from \"./KeyLetter/KeyLetter\";\nimport { IAppState } from \"../../types/state\";\nimport { connect } from \"react-redux\";\nimport './MascSection.scss'\n\ninterface MascSectionProps {\n    letterValues: string[];\n}\n\nclass MascSection extends React.Component<MascSectionProps> {\n    render() {\n\n        let keyLetters : JSX.Element[] = [];\n        for (let i=0; i<alphabet.length; i++) {\n            keyLetters.push(<KeyLetter key={i} index={i} value={this.props.letterValues[i]} />)\n        }\n\n        // AlphabetDisplayHeader below is used from the\n        // CSS definitions for the <AlphabetDisplay> component\n        return <div>\n            <div className=\"MascSection\">\n                <div className=\"header\">\n                    <p className=\"plaintextLabel\">Plaintext</p>\n                    <p className=\"ciphertextLabel\">Ciphertext</p>\n                </div>\n                { keyLetters }\n            </div>\n        </div>;\n    }\n}\n\nfunction mapStateToProps(state: IAppState): MascSectionProps {\n    return { letterValues: state.mascSection.letters };\n}\n\nexport default connect(mapStateToProps)(MascSection);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { IAppState } from \"../../types/state\";\nimport { myDispatcher, updateCaesarLetter } from \"../../store/actionGenerators\";\nimport { generateCiphertextAlphabet } from \"../../crypto/caesar\";\nimport './CaesarSection.scss'\nimport AlphabetDisplay from \"../AlphabetDisplay/AlphabetDisplay\";\n\ninterface CaesarSectionProps {\n    shift: number;\n};\n\nclass CaesarSection extends React.Component<CaesarSectionProps> {\n    render() {\n        return <div>\n            <div className=\"CaesarSection\">\n                <label>Shift</label>\n                <input type=\"number\" value={this.props.shift} onChange={evt => this.handleKeyLetterChange(evt)} />\n            </div>\n            <AlphabetDisplay ctAlphabet={this.getCtAlphabet()} />\n        </div>\n    }\n\n    handleKeyLetterChange(evt: React.ChangeEvent<HTMLInputElement>) {\n        let shift = evt.target.value;\n        myDispatcher(updateCaesarLetter(parseInt(shift)));\n    }\n\n    getCtAlphabet(): string {\n        return generateCiphertextAlphabet(this.props.shift);\n    }\n}\n\nfunction mapStateToProps(state: IAppState): CaesarSectionProps {\n    return {\n        shift: state.caesarSection.shift\n    }\n}\n\nexport default connect(mapStateToProps)(CaesarSection);\n","import { IAppState } from \"../../types/state\";\nimport React from \"react\";\nimport { Ciphers } from \"../../types/ciphers\";\nimport KeywordSection from \"../KeywordSection/KeywordSection\";\nimport { connect } from \"react-redux\";\nimport CipherSelector from \"../CipherSelector/CipherSelector\";\nimport MascSection from \"../MascSection/MascSection\";\nimport CaesarSection from \"../CaesarSection/CaesarSection\";\n\ninterface CiphersSectionProps {\n    cipher: Ciphers;\n};\n\nclass CiphersSection extends React.Component<CiphersSectionProps> {\n    render() {\n        return <div>\n            <CipherSelector />\n            { this.props.cipher === Ciphers.KEYWORD && <KeywordSection /> }\n            { this.props.cipher === Ciphers.MASC && <MascSection /> }\n            { this.props.cipher === Ciphers.CAESAR && <CaesarSection /> }\n        </div>\n    }\n}\n\nfunction mapStateToProps (state: IAppState): CiphersSectionProps {\n    return {\n        cipher: state.cipher\n    };\n}\n\n// export default KeySection;\nexport default connect(mapStateToProps)(CiphersSection);\n","import React from \"react\";\nimport './Credits.scss';\n\nconst Credits: React.FunctionComponent = () => {\n    return <div className=\"Credits\">\n        <p>Created by <a className=\"name\" href=\"https://github.com/maples3\">Anthony Mapes</a> for <span className=\"course\">CSC 483 (Cryptology)</span> at <span className=\"university\">Northern Kentucky University</span>.</p>\n    </div>;\n};\n\nexport default Credits;\n","import React from 'react';\nimport './App.scss';\nimport InputBox from '../InputBox/InputBox';\nimport OutputBox from '../OutputBox/OutputBox';\nimport { Provider } from 'react-redux';\nimport { store } from '../../store/configureStore';\nimport CiphersSection from '../CiphersSection/CiphersSection';\nimport Credits from '../Credits/Credits';\n\nconst App: React.FC = () => {\n  return (\n    <Provider store={store}>\n      <div className=\"App\">\n        <h1>Krypter</h1>\n        <InputBox />\n        <CiphersSection />\n        <OutputBox />\n        <Credits />\n      </div>\n    </Provider>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\n// import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}