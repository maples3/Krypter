{"version":3,"sources":["types/ciphers.ts","types/actions.ts","types/state.ts","crypto/common.ts","crypto/keyword.ts","store/reducers/keywordReducer.ts","crypto/masc.ts","store/reducers/mascReducer.ts","crypto/caesar.ts","store/reducers/caesarReducer.ts","store/reducers/formattingReducer.ts","store/reducers/cryptoReducer.ts","store/reducers/mainReducer.ts","store/configureStore.ts","store/actionGenerators.ts","components/InputBox/InputBox.tsx","components/OutputBox/OutputBox.tsx","components/KeywordSection/KeyInput/KeyInput.tsx","components/AlphabetDisplay/AlphabetDisplay.tsx","components/KeywordSection/KeywordSection.tsx","components/CipherSelector/CipherSelector.tsx","components/MascSection/KeyLetter/KeyLetter.tsx","components/MascSection/MascSection.tsx","components/CaesarSection/CaesarSection.tsx","components/CiphersSection/CiphersSection.tsx","components/Credits/Credits.tsx","components/App/App.tsx","index.tsx"],"names":["Ciphers","UPDATE_INPUT","UPDATE_CIPHERSECTION","UPDATE_KEYWORDSECTION","UPDATE_MASCLETTER","UPDATE_CAESARSECTION","defaultState","input","output","cipher","CAESAR","decrypt","preserveFormatting","keywordSection","keyword","keyletter","validKeyword","validKeyletter","mascSection","letters","Array","fill","caesarSection","shift","alphabet","encryptTextFromCtAlphabet","plaintext","ctAlphabet","ptAlphabet","ciphertext","i","length","indexOf","toLowerCase","generateCiphertextAlphabet","unshiftedCtAlphabet","stripDuplicateLetters","toUpperCase","startIndex","charCodeAt","keywordSectionReducer","ks","action","isValidKeyword","isValidKeyletter","keyLetter","keywordEncrypt","keySectionValid","keywordDecrypt","inputCiphertext","decryptText","num","PAD_CHARACTER","alphabetUppercaseArray","from","convertAlphabets","srcAlphabet","destAlphabet","out","charIndex","mascSectionReducer","ms","newLetter","newValue","includes","changedIndex","mascEncrypt","ctLetters","mascDecrypt","map","currVal","index","join","caesarSectionReducer","cs","caesarEncrypt","caesarDecrypt","BLOCK_LENGTH","formattingReducer","str","newOutput","ch","test","stripNonAlpha","blockLength","splitIntoBlocks","generateOutput","state","formattedInput","KEYWORD","MASC","mainReducer","type","inputText","store","createStore","composeWithDevTools","updateKeywordSection","updateCipherSelector","myDispatcher","dispatch","InputBox","props","className","onChange","evt","updateInputValue","value","this","newInput","target","setState","React","Component","connect","OutputBox","readOnly","KeyInput","updateKeywordValue","updateKeyLetterValue","newKeyword","newKeyletter","AlphabetDisplay","generateAlphabets","push","key","KeywordSection","getCtAlphabet","cipherList","Map","CipherSelector","options","forEach","enumValue","displayName","selected","handleCipherChange","name","checked","handleDirectionChange","handlePreserveFormattingChange","get","undefined","KeyLetter","handleChange","updateMascLetter","MascSection","keyLetters","letterValues","CaesarSection","handleKeyLetterChange","newShift","parseInt","CiphersSection","Credits","href","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.7bb0c9b4.chunk.js","sourcesContent":["\r\nexport enum Ciphers {\r\n    KEYWORD = \"Keyword\",\r\n    MASC = \"MASC\",\r\n    CAESAR = \"CAESAR\"\r\n}\r\n","import { Ciphers } from \"./ciphers\";\r\n\r\nexport const UPDATE_INPUT = \"UPDATE_INPUT\";\r\nexport const UPDATE_CIPHERSECTION = \"UPDATE_CIPHERSECTION\";\r\nexport const UPDATE_KEYWORDSECTION = \"UPDATE_KEYWORDSECTION\";\r\nexport const UPDATE_MASCLETTER = \"UPDATE_MASCLETTER\";\r\nexport const UPDATE_CAESARSECTION = \"UPDATE_CAESARSECTION\";\r\n\r\nexport interface UpdateKeywordSectionAction {\r\n    type: typeof UPDATE_KEYWORDSECTION;\r\n    keyword: string;\r\n    keyLetter: string;\r\n}\r\n\r\nexport interface UpdateInputAction {\r\n    type: typeof UPDATE_INPUT;\r\n    inputText: string;\r\n}\r\n\r\nexport interface UpdateCipherSectionAction {\r\n    type: typeof UPDATE_CIPHERSECTION;\r\n    cipher: Ciphers;\r\n    decrypt: boolean;\r\n    preserveFormatting: boolean;\r\n}\r\n\r\nexport interface UpdateMascLetterAction {\r\n    type: typeof UPDATE_MASCLETTER;\r\n    changedIndex: number;\r\n    newValue: string;\r\n}\r\n\r\nexport interface UpdateCaesarAction {\r\n    type: typeof UPDATE_CAESARSECTION;\r\n    shift: number;\r\n}\r\n\r\n// Aggregate type for all actions\r\nexport type AppActions = UpdateKeywordSectionAction | UpdateInputAction | UpdateCipherSectionAction | UpdateMascLetterAction | UpdateCaesarAction;\r\n","import { Ciphers } from \"./ciphers\";\r\n\r\nexport interface IAppState {\r\n    input: string;\r\n    output: string;\r\n    cipher: Ciphers;\r\n    decrypt: boolean;\r\n    preserveFormatting: boolean;\r\n    keywordSection: IKeywordSection;\r\n    mascSection: IMascSection;\r\n    caesarSection: ICaesarSection;\r\n}\r\n\r\nexport interface IKeywordSection {\r\n    keyword: string;\r\n    validKeyword: boolean;\r\n    keyletter: string;\r\n    validKeyletter: boolean;\r\n}\r\n\r\nexport interface ICaesarSection {\r\n    shift: number;\r\n}\r\n\r\nexport interface IMascSection {\r\n    letters: string[]; // exactly 26 elements, the CT letters in order as they correlate to the standard alphabet\r\n}\r\n\r\nexport const defaultState: IAppState = {\r\n    input: \"Enter your text here...\",\r\n    output: \"\",\r\n    \r\n    cipher: Ciphers.CAESAR,\r\n    decrypt: false,\r\n    preserveFormatting: true,\r\n\r\n    keywordSection: {\r\n        keyword: \"\",\r\n        keyletter: \"\",\r\n        validKeyword: false,\r\n        validKeyletter: false\r\n    },\r\n\r\n    mascSection: {\r\n        // Bad things happen if the array isn't already populated with empty strings\r\n        // If you set value={undefined} on an input element, it's not considered controlled.\r\n        // I want my KeyLetter <input>s to be controlled, so the array needs to be filled with\r\n        // something other than `undefined`.  An empty string works beautifully.\r\n        // https://reactjs.org/docs/forms.html#controlled-input-null-value\r\n        letters: Array<string>(26).fill(\"\")\r\n    },\r\n\r\n    caesarSection: {\r\n        shift: 0\r\n    }\r\n};\r\n","export const alphabet = \"abcdefghijklmnopqrstuvwxyz\";\r\n\r\n// This function assumes that {ctAlphabet} is UPPERCASE, and {alphabet} is lowercase\r\n// You can use this function to decrypt by putting the plaintext alphabet in {ctAlphabet} and vice versa\r\n// (just make sure you convert them to the proper case first!)\r\nexport function encryptTextFromCtAlphabet(plaintext: string, ctAlphabet: string, ptAlphabet: string) {\r\n    // Remember: {ctAlphabet} is UPPERCASE, {alphabet} is lowercase\r\n    let ciphertext = \"\";\r\n    \r\n    for (let i=0; i < plaintext.length; i++) {\r\n        // If the plaintext is lowercase\r\n        if ( ptAlphabet.indexOf(plaintext[i]) !== -1 ) {\r\n            // console.log('lowercase')\r\n            let charIndex = ptAlphabet.indexOf(plaintext[i]); // grab the index in the alphabet\r\n            let newChar = ctAlphabet[charIndex]; // grab the corresponding ciphertext letter\r\n            ciphertext += newChar.toLowerCase(); // Append lowercase letter to ciphertext\r\n        }\r\n        // If the plaintext is uppercase\r\n        else if ( ptAlphabet.indexOf(plaintext[i].toLowerCase()) !== -1 ) {\r\n            // Same steps as above, but swapping the case\r\n            let charIndex = ptAlphabet.indexOf(plaintext[i].toLowerCase());\r\n            let newChar = ctAlphabet[charIndex];\r\n            ciphertext += newChar;\r\n        }\r\n        // If it's not a letter, then just copy it to the ciphertext\r\n        else {\r\n            ciphertext += plaintext[i];\r\n        }\r\n    }\r\n\r\n    return ciphertext;\r\n}\r\n","/*****************************************\r\n *** NOTE ***\r\n * All functions in this file assume that the keyword and keyletter has been properly sanitized.\r\n * \"Properly sanitized\" means that the keyword contains only letters, and that the keyletter is\r\n * exactly one character long.\r\n * \r\n * Also, all plaintext alphabets will be returned lowercase, and ciphertext alphabets will be uppercase.\r\n *****************************************/\r\nimport { alphabet, encryptTextFromCtAlphabet } from './common';\r\n\r\nexport function encryptText(plaintext: string, keyword: string, keyletter: string) {\r\n    return encryptTextFromCtAlphabet(plaintext, generateCiphertextAlphabet(keyword, keyletter), alphabet);\r\n}\r\n\r\nexport function decryptText(inputCiphertext: string, keyword: string, keyletter: string) {\r\n    let ctAlphabet = generateCiphertextAlphabet(keyword, keyletter);\r\n    return encryptTextFromCtAlphabet(inputCiphertext, alphabet.toUpperCase(), ctAlphabet.toLowerCase());\r\n}\r\n\r\nfunction stripDuplicateLetters(input: string) {\r\n    let output: string = \"\";\r\n    for (let i=0; i<input.length; i++) {\r\n        if (output.indexOf(input[i].toLowerCase()) === -1) {\r\n            output += input[i].toLowerCase();\r\n        }\r\n    }\r\n    return output;\r\n}\r\n\r\nexport function generateCiphertextAlphabet(keyword: string, keyletter: string) {\r\n    let unshiftedCtAlphabet = stripDuplicateLetters(keyword + alphabet).toUpperCase();\r\n    let ctAlphabet = \"\";\r\n    let startIndex = keyletter.toLowerCase().charCodeAt(0) - 97;\r\n\r\n    for (let i=0; i<26; i++) {\r\n        let nextLetterIndex = (i + (26 - startIndex)) % 26\r\n        ctAlphabet += unshiftedCtAlphabet[nextLetterIndex];\r\n    }\r\n\r\n    return ctAlphabet;\r\n}\r\n","import { IKeywordSection } from \"../../types/state\";\r\nimport { UpdateKeywordSectionAction } from \"../../types/actions\";\r\nimport { encryptText, decryptText } from \"../../crypto/keyword\";\r\n\r\nexport function keywordSectionReducer(ks: IKeywordSection, action: UpdateKeywordSectionAction): IKeywordSection {\r\n    // If they are valid OR empty, allow them into the state\r\n    if (isValidKeyword(action.keyword) || action.keyword.length === 0) {\r\n        ks = { ...ks,\r\n            keyword: action.keyword\r\n        };\r\n    }\r\n    if (isValidKeyletter(action.keyLetter) || action.keyLetter.length === 0) {\r\n        ks = { ...ks,\r\n            keyletter: action.keyLetter\r\n        };\r\n    }\r\n    \r\n    // Validate!\r\n    ks = { ...ks,\r\n        validKeyword: isValidKeyword(ks.keyword),\r\n        validKeyletter: isValidKeyletter(ks.keyletter)\r\n    }\r\n    \r\n    return ks;\r\n}\r\n\r\nexport function keywordEncrypt(ks: IKeywordSection, input: string): string {\r\n    return keySectionValid(ks) ? encryptText(input, ks.keyword, ks.keyletter) : \"\";\r\n}\r\n\r\nexport function keywordDecrypt(ks: IKeywordSection, input: string): string {\r\n    return keySectionValid(ks) ? decryptText(input, ks.keyword, ks.keyletter) : \"\";\r\n}\r\n\r\nfunction keySectionValid(ks: IKeywordSection): boolean {\r\n    return isValidKeyword(ks.keyword) && isValidKeyletter(ks.keyletter);\r\n}\r\n\r\nfunction isValidKeyword(input: string) {\r\n    if (input.length === 0) {\r\n        return false;\r\n    }\r\n    for (var i = 0; i < input.length; i++) {\r\n        let num = input.toLowerCase().charCodeAt(i) - 97;\r\n        if (num < 0 || num > 25) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isValidKeyletter(input: string) {\r\n    return (input.length === 1) && isValidKeyword(input);\r\n}\r\n","import { alphabet } from \"./common\";\r\n\r\nconst PAD_CHARACTER = \"*\"; // for when a letter hasn't been typed yet\r\n\r\nexport function encryptText(plaintext: string, ctLetters: string[]): string {\r\n    return convertAlphabets(alphabetUppercaseArray(), ctLetters, plaintext);\r\n}\r\n\r\nexport function decryptText(ciphertext: string, ctLetters: string[]): string {\r\n    return convertAlphabets(ctLetters, alphabetUppercaseArray(), ciphertext);\r\n}\r\n\r\nfunction alphabetUppercaseArray(): string[] {\r\n    return Array.from(alphabet.toUpperCase());\r\n}\r\n\r\n// This function assumes that both alphabets are given as UPPERCASE\r\n// Either srcAlphabet or destAlphabet could have missing elements, depending on if we're encrypting or decrypting\r\n// So we need to account for empty slots in either!\r\nfunction convertAlphabets(srcAlphabet: string[], destAlphabet: string[], input: string): string {\r\n    let out = \"\";\r\n    \r\n    for (let i = 0; i < input.length; i++) {\r\n        // if the input is uppercase\r\n        if (srcAlphabet.indexOf(input[i]) !== -1) {\r\n            let charIndex = srcAlphabet.indexOf(input[i]);\r\n            // Check that the destination char exists, otherwise pad\r\n            if (destAlphabet[charIndex] === \"\") {\r\n                out += PAD_CHARACTER;\r\n            } else {\r\n                out += destAlphabet[charIndex];\r\n            }\r\n        }\r\n        // if the input is lowercase\r\n        else if (srcAlphabet.indexOf(input[i].toUpperCase()) !== -1) {\r\n            // Same as above, but lowercase\r\n            let charIndex = srcAlphabet.indexOf(input[i].toUpperCase());\r\n            if (destAlphabet[charIndex] === \"\") {\r\n                out += PAD_CHARACTER;\r\n            } else {\r\n                out += destAlphabet[charIndex].toLowerCase();\r\n            }\r\n        }\r\n        // if the character is alpha but not in srcAlphabet (upper or lower case)\r\n        else if (alphabet.indexOf(input[i]) !== -1 || alphabet.toUpperCase().indexOf(input[i]) !== -1 ) {\r\n            out += PAD_CHARACTER;\r\n        }\r\n        // if it's not a letter at all, then just copy from the input\r\n        else {\r\n            out += input[i];\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n","import { IMascSection } from \"../../types/state\";\r\nimport { UpdateMascLetterAction } from \"../../types/actions\";\r\nimport { encryptText, decryptText } from \"../../crypto/masc\";\r\n\r\nexport function mascSectionReducer(ms: IMascSection, action: UpdateMascLetterAction): IMascSection {\r\n    let newLetter = action.newValue.toUpperCase();\r\n    \r\n    // The new letter must be 0 or 1 characters long.\r\n    // It also must either be empty or not already exist in the array.\r\n    if (newLetter.length < 2 && ( newLetter === \"\" || !ms.letters.includes(newLetter) )) {\r\n        ms.letters[action.changedIndex] = newLetter;\r\n    }\r\n    \r\n    // The array object itself needs to change, otherwise React doesn't react to the change.\r\n    ms.letters = Array.from(ms.letters);\r\n\r\n    return ms;\r\n}\r\n\r\nexport function mascEncrypt(ms: IMascSection, input: string): string {\r\n    return encryptText(input, ms.letters);\r\n}\r\n\r\nexport function mascDecrypt(ms: IMascSection, input: string): string {\r\n    return decryptText(input, ms.letters);\r\n}\r\n","/*\r\nNOTE: All exported functions expect the input to be sanitized.\r\n(meaning, 'keyletter' is a single UPPERCASE letter)\r\n*/\r\n\r\nimport { alphabet, encryptTextFromCtAlphabet } from './common';\r\n\r\nexport function encryptText(plaintext: string, shift: number) {\r\n    return encryptTextFromCtAlphabet(plaintext, generateCiphertextAlphabet(shift), alphabet);\r\n}\r\n\r\nexport function decryptText(inputCiphertext: string, shift: number) {\r\n    let ctAlphabet = generateCiphertextAlphabet(shift);\r\n    return encryptTextFromCtAlphabet(inputCiphertext, alphabet.toUpperCase(), ctAlphabet.toLowerCase());\r\n}\r\n\r\nexport function generateCiphertextAlphabet(shift: number): string {\r\n    let ctAlphabetArray = Array.from(alphabet).map(\r\n        (currVal: string, index: number) => { return alphabet[(index + shift) % 26]; }\r\n    );\r\n    return ctAlphabetArray.join('').toUpperCase();\r\n}\r\n","import { ICaesarSection } from \"../../types/state\";\r\nimport { UpdateCaesarAction } from \"../../types/actions\";\r\nimport { encryptText, decryptText } from \"../../crypto/caesar\";\r\n\r\nexport function caesarSectionReducer(cs: ICaesarSection, action: UpdateCaesarAction): ICaesarSection {\r\n    cs.shift = (action.shift + 26) % 26; // Don't allow negative numbers\r\n    return cs;\r\n}\r\n\r\nexport function caesarEncrypt(cs: ICaesarSection, input: string): string {\r\n    return encryptText(input, cs.shift);\r\n}\r\n\r\nexport function caesarDecrypt(cs: ICaesarSection, input: string): string {\r\n    return decryptText(input, cs.shift);\r\n}\r\n","const BLOCK_LENGTH = 5;\r\n\r\nexport function formattingReducer(str: string, preserveFormatting: boolean): string {\r\n    if (! preserveFormatting) {\r\n        let newOutput = stripNonAlpha(str);\r\n        newOutput = newOutput.toUpperCase();\r\n        newOutput = splitIntoBlocks(newOutput, BLOCK_LENGTH);\r\n        return newOutput;\r\n    } else {\r\n        return str;\r\n    }\r\n}\r\n\r\nfunction stripNonAlpha(str: string): string {\r\n    let out = \"\";\r\n\r\n    for(let i=0; i<str.length; i++) {\r\n        if (isAlpha(str[i])) {\r\n            out += str[i];\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nfunction splitIntoBlocks(str: string, blockLength: number): string {\r\n    let out = \"\";\r\n    for (let i=0; i<str.length; i++) {\r\n        out += str[i];\r\n\r\n        if (i>0 && (i+1) % blockLength === 0) {\r\n            out += \" \";\r\n        }\r\n    }\r\n    return out;\r\n}\r\n\r\n// Thanks StackOverflow\r\n// https://stackoverflow.com/questions/40120915/javascript-function-that-returns-true-if-a-letter\r\nfunction isAlpha(ch: string): boolean {\r\n    return /^[A-Z]$/i.test(ch);\r\n}\r\n","import { IAppState } from \"../../types/state\";\r\nimport { Ciphers } from \"../../types/ciphers\";\r\nimport { keywordDecrypt, keywordEncrypt } from \"./keywordReducer\";\r\nimport { mascDecrypt, mascEncrypt } from \"./mascReducer\";\r\nimport { caesarDecrypt, caesarEncrypt } from \"./caesarReducer\";\r\nimport { formattingReducer } from \"./formattingReducer\";\r\n\r\nexport function generateOutput(state: IAppState): string {\r\n\r\n    let formattedInput = formattingReducer(state.input, state.preserveFormatting);\r\n\r\n    switch (state.cipher) {\r\n        case Ciphers.KEYWORD:\r\n            return state.decrypt ? keywordDecrypt(state.keywordSection, formattedInput) : keywordEncrypt(state.keywordSection, formattedInput);\r\n        \r\n        case Ciphers.MASC:\r\n            return state.decrypt ? mascDecrypt(state.mascSection, formattedInput) : mascEncrypt(state.mascSection, formattedInput);\r\n\r\n        case Ciphers.CAESAR:\r\n            return state.decrypt ? caesarDecrypt(state.caesarSection, formattedInput) : caesarEncrypt(state.caesarSection, formattedInput);\r\n    }\r\n}\r\n","import { AppActions, UPDATE_KEYWORDSECTION, UPDATE_INPUT, UPDATE_CIPHERSECTION, UPDATE_MASCLETTER, UPDATE_CAESARSECTION } from \"../../types/actions\";\r\nimport { IAppState, defaultState } from \"../../types/state\";\r\nimport { keywordSectionReducer} from \"./keywordReducer\";\r\nimport { mascSectionReducer } from \"./mascReducer\";\r\nimport { generateOutput } from \"./cryptoReducer\";\r\nimport { caesarSectionReducer } from \"./caesarReducer\";\r\n\r\nfunction mainReducer (state: IAppState = defaultState, action: AppActions): IAppState {\r\n\r\n    switch (action.type) {\r\n        case UPDATE_CIPHERSECTION:\r\n            state = { ...state,\r\n                cipher: action.cipher,\r\n                decrypt: action.decrypt,\r\n                preserveFormatting: action.preserveFormatting,\r\n                output: \"\",\r\n            }\r\n            break;\r\n\r\n        case UPDATE_KEYWORDSECTION:\r\n            state = { ...state,\r\n                keywordSection: keywordSectionReducer(state.keywordSection, action)\r\n            }\r\n            break;\r\n\r\n        case UPDATE_MASCLETTER:\r\n            state = { ...state,\r\n                mascSection: mascSectionReducer(state.mascSection, action)\r\n            }\r\n            break;\r\n\r\n        case UPDATE_CAESARSECTION:\r\n            state = { ...state,\r\n                caesarSection: caesarSectionReducer(state.caesarSection, action)\r\n            }\r\n            break;\r\n        \r\n        case UPDATE_INPUT:\r\n            state = { ...state, input: action.inputText }\r\n    }\r\n\r\n    \r\n    // At the end of every update, recalculate the output based on the cipher and en/de-crypt selections\r\n    state = { ...state,\r\n        output: generateOutput(state)\r\n    }\r\n\r\n    return state;\r\n}\r\n\r\nexport default mainReducer;\r\n","import { createStore } from 'redux';\r\nimport { composeWithDevTools } from 'redux-devtools-extension';\r\nimport mainReducer from './reducers/mainReducer';\r\n\r\nexport const store = createStore(mainReducer, composeWithDevTools());\r\n","import { AppActions, UPDATE_KEYWORDSECTION, UPDATE_INPUT, UPDATE_CIPHERSECTION, UPDATE_MASCLETTER, UpdateMascLetterAction, UpdateCipherSectionAction, UpdateInputAction, UpdateKeywordSectionAction, UpdateCaesarAction, UPDATE_CAESARSECTION } from \"../types/actions\";\r\nimport { store } from \"./configureStore\";\r\nimport { Ciphers } from \"../types/ciphers\";\r\n\r\nexport function updateKeywordSection(keyword: string, keyLetter: string): UpdateKeywordSectionAction {\r\n    return {\r\n        type: UPDATE_KEYWORDSECTION,\r\n        keyword: keyword,\r\n        keyLetter: keyLetter\r\n    };\r\n}\r\n\r\nexport function updateInput(input: string): UpdateInputAction {\r\n    return {\r\n        type: UPDATE_INPUT,\r\n        inputText: input\r\n    };\r\n}\r\n\r\nexport function updateCipherSelector(cipher: Ciphers, decrypt: boolean, preserveFormatting: boolean): UpdateCipherSectionAction {\r\n    return {\r\n        type: UPDATE_CIPHERSECTION,\r\n        cipher,\r\n        decrypt,\r\n        preserveFormatting\r\n    };\r\n}\r\n\r\nexport function updateMascLetter(changedIndex: number, newValue: string): UpdateMascLetterAction {\r\n    return {\r\n        type: UPDATE_MASCLETTER,\r\n        changedIndex,\r\n        newValue\r\n    };\r\n}\r\n\r\nexport function updateCaesarLetter(newShift: number): UpdateCaesarAction {\r\n    return {\r\n        type: UPDATE_CAESARSECTION,\r\n        shift: newShift\r\n    }\r\n}\r\n\r\n// Is this hacky?  It seems so simple, but nothing online even came close to suggesting it...\r\nexport function myDispatcher(action: AppActions) {\r\n    store.dispatch(action);\r\n}\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { IAppState } from \"../../types/state\";\r\nimport { myDispatcher, updateInput } from \"../../store/actionGenerators\";\r\n\r\ninterface InputBoxProps {\r\n    input: string\r\n}\r\n\r\ninterface InputBoxState {\r\n    input: string\r\n}\r\n\r\nclass InputBox extends React.Component<InputBoxProps, InputBoxState> {\r\n    constructor(props: InputBoxProps) {\r\n        super(props);\r\n        this.state = { input: this.props.input };\r\n    }\r\n\r\n    render() {\r\n        return <div className='InputBox'>\r\n            <textarea onChange={evt => this.updateInputValue(evt)} value={this.state.input}></textarea>\r\n        </div>;\r\n    }\r\n\r\n    updateInputValue(evt: React.ChangeEvent<HTMLTextAreaElement>) {\r\n        let newInput = evt.target.value;\r\n        this.setState({ input: newInput });\r\n        myDispatcher(updateInput(newInput));\r\n    }\r\n}\r\n\r\nfunction mapStateToProps(state: IAppState): InputBoxProps {\r\n    return { input: state.input };\r\n}\r\n\r\nexport default connect(mapStateToProps)(InputBox);\r\n","import React from 'react'\r\nimport { IAppState } from '../../types/state';\r\nimport { connect } from 'react-redux';\r\n\r\ninterface OutputBoxProps {\r\n    output: string;\r\n}\r\n\r\ninterface OutputBoxState {\r\n}\r\n\r\nclass OutputBox extends React.Component<OutputBoxProps, OutputBoxState> {\r\n    render() {\r\n        return <div className='OutputBox'>\r\n            <textarea value={this.props.output} readOnly></textarea>\r\n        </div>;\r\n    }\r\n}\r\n\r\nfunction mapStateToProps(state: IAppState): OutputBoxProps {\r\n    return { output: state.output };\r\n}\r\n\r\nexport default connect(mapStateToProps)(OutputBox);\r\n","import React from \"react\";\r\nimport { myDispatcher, updateKeywordSection } from \"../../../store/actionGenerators\";\r\nimport './KeyInput.scss';\r\n\r\ninterface KeyInputProps {\r\n        keyword: string;\r\n        keyletter: string;\r\n}\r\n\r\nclass KeyInput extends React.Component<KeyInputProps> {\r\n    constructor(props: KeyInputProps) {\r\n        super(props);\r\n        this.state = { keyword: \"\", keyletter: \"\" };\r\n    }\r\n\r\n    render() {\r\n        return <div className=\"KeyInput\">\r\n            <label>Keyword</label>\r\n            <input type=\"text\" value={this.props.keyword} onChange={evt => this.updateKeywordValue(evt)} />\r\n\r\n            <label>Key letter</label>\r\n            <input type=\"text\" value={this.props.keyletter} onChange={evt => this.updateKeyLetterValue(evt)} />\r\n        </div>;\r\n    }\r\n\r\n    updateKeywordValue(evt: React.ChangeEvent<HTMLInputElement>) {\r\n        var newKeyword = evt.target.value;\r\n        this.setState({ keyword: newKeyword });\r\n        myDispatcher(updateKeywordSection(newKeyword, this.props.keyletter));\r\n    }\r\n\r\n    updateKeyLetterValue(evt: React.ChangeEvent<HTMLInputElement>) {\r\n        var newKeyletter = evt.target.value;\r\n        this.setState({ keyletter: newKeyletter });\r\n        myDispatcher(updateKeywordSection(this.props.keyword, newKeyletter));\r\n    }\r\n}\r\n\r\nexport default KeyInput;\r\n","import React from \"react\";\r\nimport { alphabet } from \"../../crypto/common\";\r\nimport './AlphabetDisplay.scss';\r\n\r\n// ctAlphabet is expected to be exactly 26 characters long and uppercase\r\ninterface AlphabetDisplayProps {\r\n    ctAlphabet: string;\r\n}\r\n\r\nclass AlphabetDisplay extends React.Component<AlphabetDisplayProps> {\r\n    render() {\r\n        return <div className=\"AlphabetDisplay\">\r\n            <div className=\"AlphabetDisplayHeader\">\r\n                <p>Plaintext</p>\r\n                <p>Ciphertext</p>\r\n            </div>\r\n            {this.generateAlphabets()}\r\n        </div>;\r\n    }\r\n\r\n    generateAlphabets() : JSX.Element[] {\r\n        let letters: JSX.Element[] = [];\r\n\r\n        for (let i=0; i<alphabet.length; i++) {\r\n            letters.push(\r\n                <div className=\"AlphabetDisplayLetter\" key={i}>\r\n                    <p>{alphabet[i]}</p>\r\n                    <p>{this.props.ctAlphabet[i]}</p>\r\n                </div>\r\n            );\r\n        }\r\n\r\n        return letters;\r\n    }\r\n}\r\n\r\nexport default AlphabetDisplay;\r\n","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport './KeywordSection.scss'\r\nimport KeyInput from './KeyInput/KeyInput';\r\nimport { IKeywordSection, IAppState } from '../../types/state';\r\nimport { generateCiphertextAlphabet } from '../../crypto/keyword';\r\nimport AlphabetDisplay from '../AlphabetDisplay/AlphabetDisplay';\r\n\r\ntype KeySectionProps = IKeywordSection;\r\n\r\nclass KeywordSection extends React.Component<KeySectionProps> {\r\n    render() {\r\n        return <div className=\"KeywordSection\">\r\n            <div className=\"KeywordInputCenter\"><KeyInput keyword={this.props.keyword} keyletter={this.props.keyletter}></KeyInput></div>\r\n            \r\n            {   // Shortcut syntax to render alphabetSection only if the below 2 booleans are true\r\n                this.props.validKeyword && this.props.validKeyletter && <AlphabetDisplay ctAlphabet={this.getCtAlphabet()} />\r\n            }\r\n        </div>;\r\n    }\r\n\r\n    getCtAlphabet(): string {\r\n        return generateCiphertextAlphabet(this.props.keyword, this.props.keyletter);\r\n    }\r\n}\r\n\r\nfunction mapStateToProps (state: IAppState): KeySectionProps {\r\n    return state.keywordSection;\r\n}\r\n\r\nexport default connect(mapStateToProps)(KeywordSection);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { Ciphers } from \"../../types/ciphers\";\r\nimport { IAppState } from \"../../types/state\";\r\nimport { myDispatcher, updateCipherSelector } from \"../../store/actionGenerators\";\r\nimport './CipherSelector.scss'\r\n\r\ninterface CipherSelectorProps {\r\n    cipher: Ciphers,\r\n    preserveFormatting: boolean,\r\n    decrypt: boolean\r\n}\r\n\r\nconst cipherList = new Map<string, Ciphers>([\r\n    [\"Caesar\", Ciphers.CAESAR],\r\n    [\"MASC\", Ciphers.MASC],\r\n    [\"Keyword\", Ciphers.KEYWORD],\r\n]);\r\n\r\nclass CipherSelector extends React.Component<CipherSelectorProps> {\r\n    render() {\r\n        let options: JSX.Element[] = [];\r\n        cipherList.forEach(\r\n            (enumValue: Ciphers, displayName: string) => {\r\n                options.push(<option key={enumValue} value={displayName} selected={enumValue === this.props.cipher} >{displayName}</option>);\r\n            }\r\n        );\r\n\r\n        return <div className=\"CipherSelector\">\r\n            <div className=\"Cipher\">\r\n                <select onChange={evt => this.handleCipherChange(evt)}>\r\n                    { options }\r\n                </select>\r\n            </div>\r\n            <div className=\"Direction\">\r\n                <label><input type=\"radio\" name=\"direction\" value=\"encrypt\" checked={this.props.decrypt === false} onChange={() => this.handleDirectionChange(false)} />Encrypt</label><br />\r\n                <label><input type=\"radio\" name=\"direction\" value=\"decrypt\" checked={this.props.decrypt === true}  onChange={() => this.handleDirectionChange(true)}  />Decrypt</label>\r\n            </div>\r\n            <div className=\"PreserveFormatting\">\r\n                <label><input type=\"checkbox\" name=\"preserveFormatting\" checked={this.props.preserveFormatting} onChange={() => this.handlePreserveFormattingChange()} />Preserve Formatting</label>\r\n            </div>\r\n        </div>;\r\n    }\r\n\r\n    handleCipherChange(evt: React.ChangeEvent<HTMLSelectElement>) {\r\n        let cipher = cipherList.get(evt.target.value);\r\n        if (cipher !== undefined) {\r\n            myDispatcher(updateCipherSelector(cipher, this.props.decrypt, this.props.preserveFormatting));\r\n        }\r\n    }\r\n    \r\n    handleDirectionChange(decrypt: boolean) {\r\n        myDispatcher(updateCipherSelector(this.props.cipher, decrypt, this.props.preserveFormatting));\r\n    }\r\n    \r\n    handlePreserveFormattingChange() {\r\n        // This one is just a simple toggle\r\n        myDispatcher(updateCipherSelector(this.props.cipher, this.props.decrypt, ! this.props.preserveFormatting));\r\n    }\r\n}\r\n\r\nfunction mapStateToProps(state: IAppState): CipherSelectorProps {\r\n    return {\r\n        cipher: state.cipher,\r\n        preserveFormatting: state.preserveFormatting,\r\n        decrypt: state.decrypt\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(CipherSelector);\r\n","import React from \"react\";\r\nimport { myDispatcher, updateMascLetter } from \"../../../store/actionGenerators\";\r\nimport { alphabet } from \"../../../crypto/common\";\r\n\r\ninterface KeyLetterProps {\r\n    index: number;\r\n    value: string;\r\n};\r\n\r\nclass KeyLetter extends React.Component<KeyLetterProps> {\r\n    constructor(props: KeyLetterProps) {\r\n        super(props);\r\n        this.state = { value: this.props.value };\r\n    }\r\n\r\n    render() {\r\n        return <div>\r\n            <label>{alphabet[this.props.index]}</label>\r\n            <input type=\"text\" value={this.props.value} onChange={evt => this.handleChange(evt)} />\r\n        </div>;\r\n    }\r\n\r\n    handleChange(evt: React.ChangeEvent<HTMLInputElement>) {\r\n        let newValue = evt.target.value.toUpperCase();\r\n        myDispatcher(updateMascLetter(this.props.index, newValue));\r\n    }\r\n}\r\n\r\nexport default KeyLetter;\r\n","import React from \"react\";\r\nimport { alphabet } from \"../../crypto/common\";\r\nimport KeyLetter from \"./KeyLetter/KeyLetter\";\r\nimport { IAppState } from \"../../types/state\";\r\nimport { connect } from \"react-redux\";\r\nimport './MascSection.scss'\r\n\r\ninterface MascSectionProps {\r\n    letterValues: string[];\r\n}\r\n\r\nclass MascSection extends React.Component<MascSectionProps> {\r\n    render() {\r\n\r\n        let keyLetters : JSX.Element[] = [];\r\n        for (let i=0; i<alphabet.length; i++) {\r\n            keyLetters.push(<KeyLetter key={i} index={i} value={this.props.letterValues[i]} />)\r\n        }\r\n\r\n        // AlphabetDisplayHeader below is used from the\r\n        // CSS definitions for the <AlphabetDisplay> component\r\n        return <div>\r\n            <div className=\"MascSection\">\r\n                <div className=\"header\">\r\n                    <p className=\"plaintextLabel\">Plaintext</p>\r\n                    <p className=\"ciphertextLabel\">Ciphertext</p>\r\n                </div>\r\n                { keyLetters }\r\n            </div>\r\n        </div>;\r\n    }\r\n}\r\n\r\nfunction mapStateToProps(state: IAppState): MascSectionProps {\r\n    return { letterValues: state.mascSection.letters };\r\n}\r\n\r\nexport default connect(mapStateToProps)(MascSection);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { IAppState } from \"../../types/state\";\r\nimport { myDispatcher, updateCaesarLetter } from \"../../store/actionGenerators\";\r\nimport { generateCiphertextAlphabet } from \"../../crypto/caesar\";\r\nimport './CaesarSection.scss'\r\nimport AlphabetDisplay from \"../AlphabetDisplay/AlphabetDisplay\";\r\n\r\ninterface CaesarSectionProps {\r\n    shift: number;\r\n};\r\n\r\nclass CaesarSection extends React.Component<CaesarSectionProps> {\r\n    render() {\r\n        return <div>\r\n            <div className=\"CaesarSection\">\r\n                <label>Shift</label>\r\n                <input type=\"number\" value={this.props.shift} onChange={evt => this.handleKeyLetterChange(evt)} />\r\n            </div>\r\n            <AlphabetDisplay ctAlphabet={this.getCtAlphabet()} />\r\n        </div>\r\n    }\r\n\r\n    handleKeyLetterChange(evt: React.ChangeEvent<HTMLInputElement>) {\r\n        let shift = evt.target.value;\r\n        myDispatcher(updateCaesarLetter(parseInt(shift)));\r\n    }\r\n\r\n    getCtAlphabet(): string {\r\n        return generateCiphertextAlphabet(this.props.shift);\r\n    }\r\n}\r\n\r\nfunction mapStateToProps(state: IAppState): CaesarSectionProps {\r\n    return {\r\n        shift: state.caesarSection.shift\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(CaesarSection);\r\n","import { IAppState } from \"../../types/state\";\r\nimport React from \"react\";\r\nimport { Ciphers } from \"../../types/ciphers\";\r\nimport KeywordSection from \"../KeywordSection/KeywordSection\";\r\nimport { connect } from \"react-redux\";\r\nimport CipherSelector from \"../CipherSelector/CipherSelector\";\r\nimport MascSection from \"../MascSection/MascSection\";\r\nimport CaesarSection from \"../CaesarSection/CaesarSection\";\r\n\r\ninterface CiphersSectionProps {\r\n    cipher: Ciphers;\r\n};\r\n\r\nclass CiphersSection extends React.Component<CiphersSectionProps> {\r\n    render() {\r\n        return <div>\r\n            <CipherSelector />\r\n            { this.props.cipher === Ciphers.KEYWORD && <KeywordSection /> }\r\n            { this.props.cipher === Ciphers.MASC && <MascSection /> }\r\n            { this.props.cipher === Ciphers.CAESAR && <CaesarSection /> }\r\n        </div>\r\n    }\r\n}\r\n\r\nfunction mapStateToProps (state: IAppState): CiphersSectionProps {\r\n    return {\r\n        cipher: state.cipher\r\n    };\r\n}\r\n\r\n// export default KeySection;\r\nexport default connect(mapStateToProps)(CiphersSection);\r\n","import React from \"react\";\r\nimport './Credits.scss';\r\n\r\nconst Credits: React.FunctionComponent = () => {\r\n    return <div className=\"Credits\">\r\n        <p>Created by <a className=\"name\" href=\"https://github.com/maples3\">Anthony Mapes</a> for <span className=\"course\">CSC 483 (Cryptology)</span> at <span className=\"university\">Northern Kentucky University</span>.</p>\r\n    </div>;\r\n};\r\n\r\nexport default Credits;\r\n","import React from 'react';\r\nimport './App.scss';\r\nimport InputBox from '../InputBox/InputBox';\r\nimport OutputBox from '../OutputBox/OutputBox';\r\nimport { Provider } from 'react-redux';\r\nimport { store } from '../../store/configureStore';\r\nimport CiphersSection from '../CiphersSection/CiphersSection';\r\nimport Credits from '../Credits/Credits';\r\n\r\nconst App: React.FC = () => {\r\n  return (\r\n    <Provider store={store}>\r\n      <div className=\"App\">\r\n        <h1>Krypter</h1>\r\n        <InputBox />\r\n        <CiphersSection />\r\n        <OutputBox />\r\n        <Credits />\r\n      </div>\r\n    </Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './components/App/App';\r\n// import * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\n// serviceWorker.unregister();\r\n"],"sourceRoot":""}